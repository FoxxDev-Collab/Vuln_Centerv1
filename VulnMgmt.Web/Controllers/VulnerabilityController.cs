using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Rendering;
using VulnMgmt.Web.Models.Domain;
using VulnMgmt.Web.Models.ViewModels;
using VulnMgmt.Web.Services;

namespace VulnMgmt.Web.Controllers;

[Authorize]
public class VulnerabilityController : Controller
{
    private readonly IVulnerabilityService _vulnerabilityService;
    private readonly IHostService _hostService;
    private readonly ISiteService _siteService;
    private readonly ILogger<VulnerabilityController> _logger;

    public VulnerabilityController(
        IVulnerabilityService vulnerabilityService,
        IHostService hostService,
        ISiteService siteService,
        ILogger<VulnerabilityController> logger)
    {
        _vulnerabilityService = vulnerabilityService;
        _hostService = hostService;
        _siteService = siteService;
        _logger = logger;
    }

    public async Task<IActionResult> Index(
        int? siteId,
        int? hostId,
        Severity? severity,
        RemediationStatus? status,
        string? search,
        bool? exploitable,
        int page = 1)
    {
        var criteria = new VulnerabilitySearchCriteria
        {
            SiteId = siteId,
            HostId = hostId,
            Severity = severity,
            Status = status,
            SearchTerm = search,
            IsExploitable = exploitable,
            PageNumber = page,
            PageSize = 50
        };

        var vulnerabilities = await _vulnerabilityService.SearchAsync(criteria);
        var summary = await _vulnerabilityService.GetSummaryAsync(siteId);

        var vulnItems = vulnerabilities.Select(v => new VulnerabilityIndexItem
        {
            Id = v.Id,
            PluginId = v.PluginId,
            PluginName = v.PluginName,
            Family = v.Family,
            Severity = v.Severity,
            CVE = v.CVE,
            Synopsis = v.Synopsis,
            Port = v.Port,
            Protocol = v.Protocol,
            RemediationStatus = v.RemediationStatus,
            LastObserved = v.LastObserved,
            FirstDiscovered = v.FirstDiscovered,
            IsExploitable = v.IsExploitable,
            HostId = v.HostId,
            HostName = v.Host?.DisplayName ?? v.Host?.DNSName ?? "Unknown",
            SiteName = v.Host?.Site?.Name ?? "Unknown"
        }).ToList();

        var model = new VulnerabilityIndexViewModel
        {
            Vulnerabilities = vulnItems,
            Summary = summary,
            SiteId = siteId,
            HostId = hostId,
            SeverityFilter = severity,
            StatusFilter = status,
            SearchTerm = search,
            IsExploitableFilter = exploitable,
            PageNumber = page,
            TotalCount = vulnItems.Count
        };

        if (siteId.HasValue)
        {
            var site = await _siteService.GetByIdAsync(siteId.Value);
            model.SiteName = site?.Name;
        }

        if (hostId.HasValue)
        {
            var host = await _hostService.GetByIdAsync(hostId.Value);
            model.HostName = host?.DisplayName ?? host?.DNSName;
        }

        return View(model);
    }

    public async Task<IActionResult> Details(int id)
    {
        var vulnerability = await _vulnerabilityService.GetByIdAsync(id);
        if (vulnerability == null)
        {
            return NotFound();
        }

        var model = new VulnerabilityDetailsViewModel
        {
            Vulnerability = vulnerability,
            HostName = vulnerability.Host?.DisplayName ?? vulnerability.Host?.DNSName ?? "Unknown",
            SiteName = vulnerability.Host?.Site?.Name ?? "Unknown"
        };

        return View(model);
    }

    [Authorize(Roles = "Admin,ISSM,ISSO,SysAdmin")]
    public async Task<IActionResult> UpdateStatus(int id, string? returnUrl)
    {
        var vulnerability = await _vulnerabilityService.GetByIdAsync(id);
        if (vulnerability == null)
        {
            return NotFound();
        }

        var model = new UpdateRemediationViewModel
        {
            Id = vulnerability.Id,
            PluginName = vulnerability.PluginName,
            HostName = vulnerability.Host?.DisplayName ?? vulnerability.Host?.DNSName,
            Severity = vulnerability.Severity,
            RemediationStatus = vulnerability.RemediationStatus,
            RemediationNotes = vulnerability.RemediationNotes,
            ReturnUrl = returnUrl
        };

        return View(model);
    }

    [HttpPost]
    [ValidateAntiForgeryToken]
    [Authorize(Roles = "Admin,ISSM,ISSO,SysAdmin")]
    public async Task<IActionResult> UpdateStatus(UpdateRemediationViewModel model)
    {
        if (!ModelState.IsValid)
        {
            return View(model);
        }

        try
        {
            await _vulnerabilityService.UpdateRemediationStatusAsync(
                model.Id,
                model.RemediationStatus,
                model.RemediationNotes,
                User.Identity?.Name ?? "Unknown");

            _logger.LogInformation(
                "Vulnerability {VulnId} status updated to {Status} by {User}",
                model.Id, model.RemediationStatus, User.Identity?.Name);

            TempData["Success"] = "Remediation status updated successfully.";

            if (!string.IsNullOrEmpty(model.ReturnUrl) && Url.IsLocalUrl(model.ReturnUrl))
            {
                return Redirect(model.ReturnUrl);
            }

            return RedirectToAction(nameof(Details), new { id = model.Id });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating vulnerability {VulnId}", model.Id);
            ModelState.AddModelError(string.Empty, "An error occurred while updating the status.");
            return View(model);
        }
    }

    [HttpPost]
    [ValidateAntiForgeryToken]
    [Authorize(Roles = "Admin,ISSM,ISSO,SysAdmin")]
    public async Task<IActionResult> BulkUpdate(BulkRemediationViewModel model)
    {
        if (model.VulnerabilityIds == null || !model.VulnerabilityIds.Any())
        {
            TempData["Error"] = "No vulnerabilities selected.";
            return RedirectToAction(nameof(Index), new { siteId = model.SiteId, hostId = model.HostId });
        }

        var successCount = 0;
        var userName = User.Identity?.Name ?? "Unknown";

        foreach (var id in model.VulnerabilityIds)
        {
            try
            {
                await _vulnerabilityService.UpdateRemediationStatusAsync(id, model.NewStatus, model.Notes, userName);
                successCount++;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error updating vulnerability {VulnId} in bulk update", id);
            }
        }

        _logger.LogInformation(
            "Bulk update: {Count} vulnerabilities updated to {Status} by {User}",
            successCount, model.NewStatus, userName);

        TempData["Success"] = $"Updated {successCount} of {model.VulnerabilityIds.Count} vulnerabilities.";
        return RedirectToAction(nameof(Index), new { siteId = model.SiteId, hostId = model.HostId });
    }
}
